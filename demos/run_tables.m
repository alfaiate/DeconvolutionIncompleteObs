% This is a script file that exemplifies the use of the Proposed-AD method.
% See the file README for more information.
% 
% It corresponds to Tables I-IV given in [1], i.e., the running time 
% needed for each algorithm to produce an estimate image with an associated
% RMSE lower than 1e-3
% 
%   [1] M. Simoes, J. Bioucas-Dias, L. Almeida, and J. Chanussot, 
%        “A Framework for Fast Image Deconvolution with
%        Incomplete Observations,” IEEE Trans. Image Process.,
%        to be published.

% % % % % % % % % % % % % 
% 
% Version: 1
% 
% Can be obtained online from: 
%   https://github.com/alfaiate/DeconvolutionIncompleteObs
% 
% % % % % % % % % % % % % 
% 
% Copyright (C) 2016 Miguel Simoes
% 
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, version 3 of the License.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program. If not, see <http://www.gnu.org/licenses/>.
% 
% % % % % % % % % % % % % 
% 
% % % % % % % % % % % % % 
addpath('../src', '../src/utils', '../data');
% % % % % % % % % % % % % 

% This script has two steps. 
% % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% I. It starts by running the algos and compare them to the reference images.
% % % % % % % % % % % % % % % % % % % % % % % % % % % % 

% The following parameters can be
% modified to change the data generation:
BlurDim_vec = [5 13 21]; % Dimensions of the blur's support
image_vec = {'cameraman', 'lena'}; % Image. Can be 'cameraman', etc. Check 'data_generation.m'
blur_vec = {'uniform', 'gaussian'}; % Blur type. Can be 'gaussian', etc. Check 'data_generation.m'
BSNR = 50; % Blurred-Signal-to-Noise Ratio
total_iter = 1e6; % Total number of iterations
erro_min = 1e-3; % Minimum RMSE to terminate the algorithms

% Initialize vectors with zeros
time_AM_vec = zeros(length(image_vec),length(blur_vec),length(BlurDim_vec));
n_total_iter_AM = zeros(length(image_vec),length(blur_vec),length(BlurDim_vec));

time_ADMM_CG_vec = zeros(length(image_vec),length(blur_vec),length(BlurDim_vec));
n_total_iter_ADMM_CG = zeros(length(image_vec),length(blur_vec),length(BlurDim_vec));

time_CM_vec = zeros(length(image_vec),length(blur_vec),length(BlurDim_vec));
n_total_iter_CM = zeros(length(image_vec),length(blur_vec),length(BlurDim_vec));

time_Proposed1_vec = zeros(length(image_vec),length(blur_vec),length(BlurDim_vec));
n_total_iter_Proposed1 = zeros(length(image_vec),length(blur_vec),length(BlurDim_vec));

time_ProposedAD_vec = zeros(length(image_vec),length(blur_vec),length(BlurDim_vec));
n_total_iter_ProposedAD = zeros(length(image_vec),length(blur_vec),length(BlurDim_vec));
           
cond_numb = zeros(length(image_vec),length(blur_vec),length(BlurDim_vec));

for idx1 = 1:length(image_vec)
    for idx2 = 1:length(blur_vec)
        for idx3=1:length(BlurDim_vec)

            image = image_vec{idx1};
            blur = blur_vec{idx2};
            fprintf('Experiment: Deconvolution with unknown boundaries \n - Image: %12s \n - Blur type: %12s \n - Blur dim: %2d*%2d \n', image, blur, BlurDim_vec(idx3), BlurDim_vec(idx3));
            
            % Generates the observed image
            [ original_image, blur_kernel, observed_image ] = data_generation(image, blur, BlurDim_vec(idx3), sqrt(BlurDim_vec(idx3)), BSNR);

            % Loads the estimated image generated by AM after 1e6 iterations (reference
            % images)
            load(strcat('AM_final_', image, '_', blur, '_', num2str(BlurDim_vec(idx3))), 'final_image_full');

            % Prepare image mask
            mask = ones(size(observed_image));

            % Regularization parameter
            lambda = 5e-6;
            
            fprintf('Running... AM\n');
            miu_1 = 1;
            miu_2 = 1;
            [ ~, time_AM, ~, ~, ~, ~, ~ ] = deblur_AM( observed_image, blur_kernel, mask, total_iter, lambda, miu_1, miu_2, original_image, final_image_full, erro_min, 0, 50, 0);
            
            time_AM_vec(idx1,idx2,idx3) = time_AM(end);
            n_total_iter_AM(idx1,idx2,idx3) = length(time_AM);           

            fprintf('Running... ADMM-CG\n');
            miu_1 = 1;
            [ ~, time_ADMM_CG, ~, ~, ~, ~, ~ ] = deblur_ADMM_CG( observed_image, blur_kernel, mask, total_iter, lambda, miu_1, original_image, final_image_full, erro_min, 0, 5, 0);
            
            time_ADMM_CG_vec(idx1,idx2,idx3) = time_ADMM_CG(end);
            n_total_iter_ADMM_CG(idx1,idx2,idx3) = length(time_ADMM_CG);            
            
            fprintf('Running... CM\n');            
            miu_2 = 1e-6;
            miu_1 = 0.99/(0.5+8*miu_2);
            [ ~, time_CM, ~, ~, ~, ~, ~ ] = deblur_CM( observed_image, blur_kernel, mask, total_iter, lambda, miu_1, miu_2, original_image, final_image_full, erro_min, 0, 200, 0);
            
            time_CM_vec(idx1,idx2,idx3) = time_CM(end);
            n_total_iter_CM(idx1,idx2,idx3) = length(time_CM);   
            
            fprintf('Running... Proposed 1\n');            
            miu_1 = 1;
            miu_2 = 1;
            [ ~, time_Proposed1, ~, ~, ~, ~, ~ ] = deblur_Proposed( observed_image, blur_kernel, mask, total_iter, lambda, miu_1, miu_2, original_image, final_image_full, erro_min, 0, 50, 0);
            
            time_Proposed1_vec(idx1,idx2,idx3) = time_Proposed1(end);
            n_total_iter_Proposed1(idx1,idx2,idx3) = length(time_Proposed1);

            fprintf('Running... Proposed AD\n');            
            miu_1 = 1;
            miu_2 = (BlurDim_vec(idx3)-1)/2;
            [ ~, time_ProposedAD, ~, ~, ~, ~, ~ ] = deblur_Proposed( observed_image, blur_kernel, mask, total_iter, lambda, miu_1, miu_2, original_image, final_image_full, erro_min, 0, 50, 0);
            
            time_ProposedAD_vec(idx1,idx2,idx3) = time_ProposedAD(end);
            n_total_iter_ProposedAD(idx1,idx2,idx3) = length(time_ProposedAD);           
            
            % Half of the blur's support.
            hsize_h = floor(size(blur_kernel, 2)/2);
            hsize_w = floor(size(blur_kernel, 1)/2);
            
            % Pad image
            padval = 'linearInterpolation';
            y = padimage(observed_image, [hsize_h hsize_w], padval);
            
            % Compute condition number
            id = zeros(size(y));
            id(1, 1) = 1;
            h = imfilter(id, blur_kernel, 'circular', 'conv');
            h = h / sum(h(:)); % Filter calibration
            hf = fft2(h);
            
            cond_numb(idx1,idx2,idx3) = max(max(abs(hf)))/min(min(abs(hf)));
            
        end
    end
end


% % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% II. Builds the tables presented in [1].
% % % % % % % % % % % % % % % % % % % % % % % % % % % % 

for idx1 = 1:length(image_vec)
    for idx2 = 1:length(blur_vec)
        for idx3=1:length(BlurDim_vec)
            
            image = image_vec{idx1};
            blur = blur_vec{idx2};
            fprintf('Image: %8s, Blur: %8s, Size: %2d, k*1e3: %4.1f \n\n', image, blur, BlurDim_vec(idx3), cond_numb(idx1,idx2,idx3)*1e-3);

            fprintf('Method      | Iterations | Time [s] \n');
            fprintf('------------------------------------\n');
            fprintf('AM          | %6d     | %2.3f \n', n_total_iter_AM(idx1,idx2,idx3), (time_AM_vec(idx1,idx2,idx3)));
            fprintf('ADMM-CG     | %6d     | %2.3f \n', n_total_iter_ADMM_CG(idx1,idx2,idx3), (time_ADMM_CG_vec(idx1,idx2,idx3)));                     
            fprintf('CM          | %6d     | %2.3f \n', n_total_iter_CM(idx1,idx2,idx3), (time_CM_vec(idx1,idx2,idx3)));
            fprintf('Proposed 1  | %6d     | %2.3f \n', n_total_iter_Proposed1(idx1,idx2,idx3), time_Proposed1_vec(idx1,idx2,idx3));
            fprintf('Proposed AD | %6d     | %2.3f \n\n\n', n_total_iter_ProposedAD(idx1,idx2,idx3), (time_ProposedAD_vec(idx1,idx2,idx3)));
        end
    end
end